		
def write_krona_table( output_path, krona_data ):
    """
    @summary : write into a file the table that has to be used for creating the krona.
    @output_path : The file where the table is writing
    @krona_data : [dict] The dictionary used to write the table
    """
    out_fh = open( output_path, "w" )
    for taxon in krona_data.keys():
        out_fh.write( str(krona_data[taxon]) + "\t" + taxon + "\n" )
    out_fh.close()

def get_krona_tax_by_sample( biom, list_of_sample_names, taxonomy_key="taxonomy" ):
    """
    @summary : make a dictionary containing the taxonomy by sample.
    @biom : The biom object
    @list_of_sample_names : [list] The list of the sample names
    @taxonomy_key : [str] "taxonomy"
    """
    krona_data = dict()
    # Get taxonomy
    for sample_name in list_of_sample_names:
        col_idx = biom.find_idx( "sample", sample_name )
        for row_idx in range(len(biom.rows)):
            count = biom.data.nb_at( row_idx, col_idx )
            if count > 0:
                #print biom.rows[row_idx]["metadata"]
                taxonomy = biom.rows[row_idx]["metadata"][taxonomy_key]
                if not isinstance(taxonomy, list) and not isinstance(taxonomy, tuple):
                    taxonomy = map( str.strip, taxonomy.split(";") )
                # Clean taxonomy
                taxa_list = list()
                for taxon in taxonomy:
                    if not str(taxon).lower().startswith("unknown "):
                        taxa_list.append( taxon.replace("\t", " ") )
                cleaned_taxonomy = "\t".join(taxa_list)
                # Add taxon count
                if not krona_data.has_key(cleaned_taxonomy):
                    krona_data[cleaned_taxonomy] = 0
                krona_data[cleaned_taxonomy] = count
    return krona_data



class txt2Krona(Cmd):
    """
    @summary: Converts BIOM file to TSV file.
    format : taxonomyRDP seedID seedSequence blastSubject blastEvalue blastLength blastPercentCoverage blastPercentIdentity blastTaxonomy OTUname SommeCount sample_count"
    """
    def __init__(self, in_txt, out_krona_html):
        """
        @param in_biom: [str] Path to BIOM file.
        @param out_tsv: [str] Path to output TSV file.
        """
        Cmd.__init__( self,
                      'ktImportText ',
                      'Converts a txt file in krona html file.',
                      in_txt+ " -o "+out_krona_html)
		
			function afficher_seq() { // affiche seq
				$('#blast_heatmap').highcharts({
						chart: {
							type: 'heatmap',
							marginTop: 40,
							marginBottom: 80
						},
						title: { text: 'Number of sequences among their blast result ( identity and coverage)' },
						xAxis: { categories: ["[0 % - 50 %[", "[50 % - 80 %[", "[80 % - 90 %[", "[90 % - 95 %[", "[95 % - 100 %[", "100 % "], 
								title: {enabled: true,text: 'percentage identity'}, 
								}, 
						yAxis: { categories: ["[0 % - 50 %[", "[50 % - 80 %[", "[80 % - 90 %[", "[90 % - 95 %[", "[95 % - 100 %[", "100 % "],
							title: {enabled: true,text: 'percentage coverage'}, 
							}, 
						colorAxis: {
							min: 0,
							minColor: '#FFFFFF',
							maxColor: Highcharts.getOptions().colors[0]
						},
						legend: {
							align: 'right',
							layout: 'vertical',
							margin: 0,
							verticalAlign: 'top',
							y: 25,
							symbolHeight: 280
						},
						tooltip: { 
							formatter: function () {
								return '<b> identity percentage : </b><br>' + this.series.xAxis.categories[this.point.x] + '<br>' +' <b>coverage percentage : <br>' +this.series.yAxis.categories[this.point.y] + '<br>'+ '<b> Sequences number :<br></b>' + this.point.value + '</b>';
								} 
							}, credits: {enabled: false}, 
						series: [{
							name: 'Sales per employee',
							borderWidth: 1,
							data: data_heatmap_SEQ,
							dataLabels: {
								enabled: true,
								color: '#000000'
							}
						}]
					});
				}
				
			function afficher_otu() {
				$('#blast_heatmap').highcharts({
						chart: {
							type: 'heatmap',
							marginTop: 40,
							marginBottom: 80
						},
						title: { text: 'Number of OTUs among their blast result ( identity and coverage)' },  
						xAxis: { categories: ["[0 % - 50 %[", "[50 % - 80 %[", "[80 % - 90 %[", "[90 % - 95 %[", "[95 % - 100 %[", "100 % "], 
							title: {enabled: true,text: 'percentage identity'}, 
						},  
						yAxis: { categories: ["[0 % - 50 %[", "[50 % - 80 %[", "[80 % - 90 %[", "[90 % - 95 %[", "[95 % - 100 %[", "100 % "],
							title: {enabled: true,text: 'percentage coverage'}, 
						},  
						colorAxis: { min: 0, minColor: '#FFFFFF', maxColor: Highcharts.getOptions().colors[0] },  
						legend: { align: 'right', layout: 'vertical', margin: 0, verticalAlign: 'top', y: 25, symbolHeight: 280 },  
						tooltip: { 
							formatter: function () {
							return '<b> identity percentage : </b><br>' + this.series.xAxis.categories[this.point.x] + '<br>' +' <b>coverage percentage : <br>' +this.series.yAxis.categories[this.point.y] + '<br>'+ '<b> Otus number :<br></b>' + this.point.value + '</b>';
							} 
						}, credits: {enabled: false},  
						series: [{ 
							name: 'Sales per employee', 
							borderWidth: 1, 
							data: data_heatmap_OTU, 
							dataLabels: { 
								enabled: true, color: '#000000' 
							} 
						}]  
					});
				}
				